-- ------------------------------------------------------------------------
-- DEATH CIRCLE
-- ------------------------------------------------------------------------
-- Death Circle is a capture the flag game design and developped by Matt.
-- Credits should stay on top of this file, tho you are free to add credits for your own enhancements.
-- Credits:
--		[*] Overall game on which "Death Circle" is running: Moliyo [http://moliyo.com]
--		[*] Original map creation: Matt from Privatia [http://privatia.serverdev.net]
--		[*] CTF Game scripting: Matt from Privatia [http://privatia.serverdev.net]
--		[*] Moral support & technical hint: Kajack & Snowcrash from Privatia [http://privatia.serverdev.net]
-- ------------------------------------------------------------------------

-- ************************************************************************
-- FILE PURPOSE: CTRL.LUA - Standard map Loading file. Loaded by deathcircle map
-- ************************************************************************

-- Load death circle configuration file.
dofile(GetResPath("deathcircle/conf.lua"))


print( "Loading deathcircle Ctrl.lua" )

function config(map)
    MapCanSavePos(map, 0)		-- 1 = Allow players to save respaw // 0 = Do not allow players to save respaw
    MapCanPK(map, 1)			-- 1 = Turns on PK Mouse Sword Icon // 0 = Turns off PK Mouse Sword Icon ( Need to press CTRL key )
    MapCanTeam( map, 0 )		-- 1 = Allow players to create party // 0 = Do not allow players to create party
    MapType( map , 4 )			-- 0 = PvP Off // 1 = PvP Off // 2 = PvP On ( Not allowed to kill Guild and Party Mates ) // 3 = PvP On ( Allowed to kill any player but not Party Mates ) // 4 = PvP On ( Not allowed to kill Guild and Party Mates )        
    MapCopyNum(map, 1)			-- 1 Copy of the map will be generated by GameServer
    SingleMapCopyPlyNum(map, 500)	-- 300 Players are allowed to enter the map
    MapCanStall(map , 0)		-- 1 = Allow players to set stall // 0 = Do not allow players to set stall
end


function get_map_entry_pos_deathcircle()
	return deathcircle_conf.port_position_x , deathcircle_conf.port_position_y
end

function init_entry(map)
    SetMapEntryMapName(map, deathcircle_conf.port_position_map)
	
    SetMapEntryTime(map, "2010/01/01/17/0", "0/0/0", "0/0/0", "0/0/0")   
end

-- ------------------------------
-- Triggered when a player successfully
-- entered the map.
-- ------------------------------
function after_enter_deathcircle( player , map_copy )
	-- This map is not standard, we will tweak players statistics here

	-- Initialize player data
	local characterName = GetChaDefaultName(player)
	AddState(player, player, 47, 10, 5)
	-- Notice ("[DEBUG] "..characterName.." is inside")
	if (deathcircle_players[characterName] == nil) then
		deathcircle_players[characterName] = { score = 0, death = 0, kill = 0, holdflagtime = 0, inside = true }
	else
		deathcircle_players[characterName].inside = true
	end
	deathcircle_playercount = deathcircle_playercount + 1
	
end

-- ------------------------------
-- Triggered when a player
-- exit the map.
-- logoff / switch / ress out.
-- ------------------------------
function before_leave_deathcircle( player )
	-- If the flag holder leave, clear the holding variable
	local characterName = GetChaDefaultName(player)
	if (deathcircle_flag_holder == characterName) then
		deathcircle_flag_holder = nil
		RemoveState(player,deathcircle_conf.flag_holder_state)
		-- SetMapEntryEventName( deathcircle_entry, deathcircle_conf.default_port_name)
	end

	-- Whoever leave the game get his points reset to 0 if he left without being killed !
	hp = Hp(player)
	if (hp > 0) then
		deathcircle_players[characterName] = { score = 0, death = 0, kill = 0, holdflagtime = 0 }
	end
  
	deathcircle_players[characterName].inside = false
	deathcircle_playercount = deathcircle_playercount - 1
end


function deathcircle_map_copy_init( map_copy )
	-- Create guardians
	if (deathcircle_conf.enable_guardians == true) then
		local guardianTypeCount = table.getn(deathcircle_conf.guardian_types)
		for i = 1,table.getn(deathcircle_conf.totem_location) do
		  -- select a random type for every location (more fun than static assignment)
		  local guardianIndex = math.random(1,guardianTypeCount)
		  local guardianType = deathcircle_conf.guardian_types[guardianIndex]
		  local guardianX = (deathcircle_conf.guardian_location[i].x)*100
		  local guardianY = (deathcircle_conf.guardian_location[i].y)*100
		  local monster = CreateChaEx(guardianType, guardianX, guardianY, 145, 21600, map_copy)
		end
	end
	
	-- Create totems
	if (deathcircle_conf.enable_totems == true) then 
		local totemTypeCount = table.getn(deathcircle_conf.totem_types)
		for i = 1,table.getn(deathcircle_conf.totem_location) do
		  -- select a random type for every location (more fun than static assignment)
		  local totemIndex = math.random(1,totemTypeCount)
		  local totemType = deathcircle_conf.totem_types[totemIndex]
		  local totemX = (deathcircle_conf.totem_location[i].x)*100
		  local totemY = (deathcircle_conf.totem_location[i].y)*100
		  local monster = CreateChaEx(totemType, totemX, totemY, 145, 21600, map_copy)
		end
	end
end

function map_run_deathcircle( map )
end

function map_copy_run_deathcircle( map_copy )
	-- Update cycle count
	deathcircle_cycle_count = deathcircle_cycle_count + 1  
	-- DEBUG : Notice ("cycle "..deathcircle_cycle_count)

	-- On the first cycle of the map, we initialize the map.
	if ( deathcircle_cycle_count == 1 ) then
		deathcircle_map_copy_init( map_copy )
	end

	-- Identify actions to achieve within this cycle.
	-- Nota: I didn't manage to get script to compile using % operator so I do modulo manually ?!
	local ignoreMobSpawn = deathcircle_cycle_count - math.floor(deathcircle_cycle_count/deathcircle_conf.random_mob_period)*deathcircle_conf.random_mob_period
	local ignoreScore = deathcircle_cycle_count - math.floor(deathcircle_cycle_count/deathcircle_conf.scoring_period)*deathcircle_conf.scoring_period
	local ignoreRanking = deathcircle_cycle_count - math.floor(deathcircle_cycle_count/deathcircle_conf.ranking_period)*deathcircle_conf.ranking_period
	local searchCheaters = deathcircle_cycle_count - math.floor(deathcircle_cycle_count/deathcircle_conf.check_cheaters_period)*deathcircle_conf.check_cheaters_period
	
	-- Give points to flag holder
	if ( ignoreScore == 0 ) then
		if (deathcircle_flag_holder ~= nil) then
			deathcircle_players[deathcircle_flag_holder].score = deathcircle_players[deathcircle_flag_holder].score + 1
			deathcircle_players[deathcircle_flag_holder].holdflagtime = deathcircle_players[deathcircle_flag_holder].holdflagtime + 1
		else
			-- There is no flag holder, give flag to first guy in queue.
			for charname,attributes in next,deathcircle_players do
			  if (attributes.inside == true) then
				local player = getPlayerByName(charname, map_copy)
				if (player ~= nil) then
					deathcircle_giveFlagTo(player)
					break
				end
			  end
			end
		end
	end
	
	-- Display current top 3
	if ( ignoreRanking == 0 ) then
		deathcircle_update_rank(true)
	end

	-- Random mob generation
	if ( ignoreMobSpawn == 0 ) then
		if (deathcircle_conf.enable_random_spawns == true) then
			-- Notice ("[DEBUG] Start Random spawn")
			for i = 1, deathcircle_conf.random_mob_count do -- randomly spawn the specified amount of mobs
				-- randomize a mob type
				local mobTypeIndex = math.random(1,table.getn(deathcircle_conf.random_mob_types))
				local mobType = deathcircle_conf.random_mob_types[mobTypeIndex]
				-- randomize a mob location
				local locationIndex = math.random(1,table.getn(deathcircle_conf.random_mob_location))
				local mobX =  deathcircle_conf.random_mob_location[locationIndex].x
				local mobY =  deathcircle_conf.random_mob_location[locationIndex].y
				-- spawn the random mob for x minutes
				--Notice ("[DEBUG] Random spawn of mob "..mobType.." at ("..mobX..","..mobY..")")
				local mob = CreateChaEx(mobType, mobX*100, mobY*100, 145, 60, map_copy)
				SetChaLifeTime(mob,deathcircle_conf.random_mob_lifelength * 60 * 1000)
			end
		end
	end
	
	-- Check for cheaters
	if (searchCheaters == 0) then
		-- Loop over players to see if they are in party
		BeginGetMapCopyPlayerCha(map_copy)
		for i = 0 , deathcircle_playercount - 1 , 1 do
			local player = GetMapCopyNextPlayerCha ( map_copy )
			local Team_In = IsInTeam(player)
			if Team_In == 1 then
				local playerName = GetChaDefaultName(player)
				-- Tell everyone about cheater
				Notice(deathcircle_conf.notice_heading.." ["..playerName.."] пытался зайти в отряде и был удалён с карты!") 
				-- kill the cheater
				BickerNotice (player, "НАРУШЕНИЕ !!!")
				MoveCity(player,"")
				-- Reset his current score
				deathcircle_players[playerName].score = 0
			end
		end
	end
end

-- ------------------------------
-- Triggered when portal closed
-- ------------------------------	
function map_copy_before_close_deathcircle( map_copy )
	-- Update ranking before checking winner
	deathcircle_update_rank(false)

	-- Remove flag holder state and add the state to the winner for a limited time.
	if (deathcircle_flag_holder ~= nil) then
		local player = getPlayerByName(deathcircle_flag_holder, map_copy)
		if (player ~= nil) then
			RemoveState(player,deathcircle_conf.flag_holder_state)
			RemoveState(player,deathcircle_conf.flag_holder_state_second)
		end
	end
	
    Notice(deathcircle_conf.notice_heading.."Захват флага Барбаросы подходит к концу...") 
	if (deathcircle_ranking.first ~= nil) then
		Notice(deathcircle_conf.notice_heading..deathcircle_ranking.first.." был сегодня лучшим ! Поздравляем !!!")
	end
	if (deathcircle_ranking.second ~= nil) then
		Notice(deathcircle_conf.notice_heading..deathcircle_ranking.second.." почти пробился вперёд !")
	end	
	if (deathcircle_ranking.third ~= nil) then
		Notice(deathcircle_conf.notice_heading..deathcircle_ranking.third.." получил средний результат !")
	end		
	
	-- Dispatch rewards
	handleRewards(map_copy)
	
	-- Reset variables
	deathcircle_players = { }
	deathcircle_flag_holder = nil
	deathcircle_ranking = { first = nil, second = nil, third = nil }
	
	-- Re-init the map
	deathcircle_init()
end

function map_copy_close_deathcircle( map_copy )
	ClearAllSubMapCha(map_copy)
	ClearAllSubMapMonster(map_copy)
end

function can_open_entry_deathcircle( map ) 
	if (deathcircle_conf.enabled == true) then
		return 1
	else
		return 0
	end
end 

-- ----------------------------------
-- CUSTOM FUNCTIONS
-- ----------------------------------

function getPlayerByName(name, map_copy)
	BeginGetMapCopyPlayerCha(map_copy)
	for i = 0 , deathcircle_playercount - 1 , 1 do
		local player = GetMapCopyNextPlayerCha ( map_copy )
		if (player == 0 or player == nil) then 
			return nil
		else
			local playerName = GetChaDefaultName(player)
			if (playerName == name) then
				return player
			end
		end
	end
end

-- Assign Flag to a given player
function deathcircle_giveFlagTo( player )
  local characterName = GetChaDefaultName(player)
	BickerNotice (player, "Вы получили флаг !")
	Notice(deathcircle_conf.notice_heading..characterName.." получил(а) флаг!")
	
	deathcircle_flag_holder = characterName
  -- Add effect to new flag holder
	AddState(player, player, deathcircle_conf.flag_holder_state, 10, 999999)
	AddState(player, player, deathcircle_conf.flag_holder_state_second, 10, 999999)
	-- Display the flag holder name on portal =P
	-- SetMapEntryEventName( deathcircle_entry, characterName.." got the flag !")
end

-- Handler to plug manually into the core player killed player function
function deathcircle_player_killed_player ( killer , dead )
	local killerName = GetChaDefaultName(killer)
	local deadName = GetChaDefaultName(dead)
	local killerScoreBonus = 0
	local deadScoreBonus = 0
	Notice("["..killerName.."] жестоко покарал ["..deadName.."] и в догонку дал пинка ^^ ")
	
	-- Adjust scores
	killerScoreBonus = 10
	BickerNotice (killer, "+"..killerScoreBonus)
	deathcircle_players[killerName].score = math.max(deathcircle_players[killerName].score + killerScoreBonus, 0)
	deathcircle_players[killerName].kill = deathcircle_players[killerName].kill + 1

	deadScoreBonus = -5
	BickerNotice (dead, "-"..deadScoreBonus)
	deathcircle_players[deadName].score = math.max(deathcircle_players[deadName].score + deadScoreBonus, 0)
	deathcircle_players[deadName].death = deathcircle_players[deadName].death + 1
	deathcircle_players[deadName].inside = false
	
	-- Send score notice to players
	local sign = "+"
	if (killerScoreBonus <= 0) then
		sign = ""
	end
	SystemNotice(killer, deathcircle_conf.notice_heading.."Текущий счёт = "..deathcircle_players[killerName].score.." ["..sign..killerScoreBonus.."]")
	sign = "+"
	if (deadScoreBonus <= 0) then
		sign = ""
	end
	SystemNotice(dead, deathcircle_conf.notice_heading.."Текущий счёт = "..deathcircle_players[deadName].score.." ["..sign..deadScoreBonus.."]")
	
	-- handle flag switch if required
	if (deathcircle_flag_holder == deadName) then
		-- Notice ("[DEBUG] Giving flag to killer")
		deathcircle_giveFlagTo(killer)
	end
end

-- Handler to plug manually into the core mob killed player function
function deathcircle_monster_killed_player ( killer , dead )
	local deadName = GetChaDefaultName(dead)
	local deadScoreBonus = 0
	Notice(deathcircle_conf.notice_heading.."["..deadName.."] отдыхает на том свете...")
	
	-- Adjust scores
	deadScoreBonus = -10
	BickerNotice (dead, "-"..deadScoreBonus)
	deathcircle_players[deadName].score = math.max(deathcircle_players[deadName].score + deadScoreBonus, 0)
	deathcircle_players[deadName].death = deathcircle_players[deadName].death + 1
	deathcircle_players[deadName].inside = false
	
	-- Send score notice to players
	local sign = "+"
	if (deadScoreBonus <= 0) then
		sign = ""
	end
	SystemNotice(dead, deathcircle_conf.notice_heading.."Текущий счёт = "..deathcircle_players[deadName].score.." ["..sign..deadScoreBonus.."]")
	
	-- Flag is lost on dying.
	if (deathcircle_flag_holder == deadName) then
		deathcircle_flag_holder = nil
	end
end

-- Generate "ranking"
function deathcircle_update_rank ( isVerbose )
	local rank1 = { name=nil, score=-1}
	local rank2 = { name=nil, score=-1}
	local rank3 = { name=nil, score=-1}

	for charname,attributes in next,deathcircle_players do
		if (attributes.score > rank1.score) then
			rank3.name = rank2.name
			rank3.score = rank2.score

			rank2.name = rank1.name
			rank2.score = rank1.score

			rank1.name = charname
			rank1.score = attributes.score
		else 
			if (attributes.score > rank2.score) then		  
				rank3.name = rank2.name
				rank3.score = rank2.score

				rank2.name = charname
				rank2.score = attributes.score
			else
				if (attributes.score > rank3.score) then
					rank3.name = charname
					rank3.score = attributes.score
				end
			end
		end
	end

	-- If verbose and the ranking changed, send a notice
	if (isVerbose == true) then 
		if ((deathcircle_ranking.first ~= rank1.name) or 
			(deathcircle_ranking.second ~= rank2.name) or
			(deathcircle_ranking.third ~= rank3.name)) then
			
			local notice = ""
			if (rank1.name ~= nil) then
				notice = notice..rank1.name.." ["..rank1.score.."]"
				if (rank2.name ~= nil) then
					notice = notice.." / "..rank2.name.." ["..rank2.score.."]"
					if (rank3.name ~= nil) then
						notice = notice.." / "..rank3.name.." ["..rank3.score.."]"
					end
				end
			end
			if (notice ~= "") then
				Notice (deathcircle_conf.notice_heading.."Положение участников: "..notice)
			end
			
			deathcircle_ranking.first = rank1.name
			deathcircle_ranking.second = rank2.name		
			deathcircle_ranking.third = rank3.name
		end
	end
end

-- Handle rewards
function handleRewards(map_copy)
	-- Avoid rewarding if rewards are disabled
	if deathcircle_conf.enable_rewards == false then
		return
	end
	
	-- Give reward to #1 player
	if deathcircle_ranking.first ~= nil then
		local player = getPlayerByName(deathcircle_ranking.first, map_copy)
		if (player ~= nil) then
			BickerNotice (player, "Получите ваши награды !")
			giveReward(player, deathcircle_conf.reward_first)
		end
	end
	
	-- Give reward to #2 player
	if deathcircle_ranking.second ~= nil then
		local player = getPlayerByName(deathcircle_ranking.second, map_copy)
		if (player ~= nil) then
			BickerNotice (player, "Получите ваши награды !")
			giveReward(player, deathcircle_conf.reward_second)
		end
	end
	
	-- Give reward to #13 player
	if deathcircle_ranking.third ~= nil then
		local player = getPlayerByName(deathcircle_ranking.third, map_copy)
		if (player ~= nil) then
			BickerNotice (player, "Получите ваши награды !")
			giveReward(player, deathcircle_conf.reward_third)
		end
	end
end

function giveReward(character, rewardSet) 
	-- Handle money reward
	if rewardSet.money >= 0 then
		AddMoney ( character , 0, rewardSet.money )
		-- SystemNotice(character, deathcircle_conf.notice_heading.."You were granted "..rewardSet.money.." gold")
	end
	
	-- Handle reputation gained
	if rewardSet.reputation >= 0 then 
		AddCreditX(character, rewardSet.reputation)
		-- SystemNotice(character, deathcircle_conf.notice_heading.."Your reputation in this world increased (+"..rewardSet.reputation..")")
	end
	
	-- Handle honor gained
	if rewardSet.honor >= 0 then 
		local medalOfValor_count = CheckBagItem( character,3849 )
		if medalOfValor_count == 1 then
			local medalOfValor = GetChaItem2 ( character , 2 , 3849 ) -- Retrieve medal of valor
			local currentHonor = GetItemAttr ( medalOfValor , ITEMATTR_VAL_STR)
			currentHonor = currentHonor + rewardSet.honor
			SetItemAttr ( medalOfValor, ITEMATTR_VAL_STR, currentHonor)
			-- SystemNotice(character, deathcircle_conf.notice_heading.."Victory increased your honor (+"..rewardSet.honor..")")
		end
	end
	
	-- Handle item rewards
	local itemCount = table.getn(rewardSet.items)
	for i = 1,itemCount do
		local inventoryFreeSlotsCount = GetChaFreeBagGridNum ( character )
		if inventoryFreeSlotsCount >= 0 then
			GiveItem ( character , 0 , rewardSet.items[i].id  , rewardSet.items[i].quantity , rewardSet.items[i].quality )
			local itemName = GetItemName(rewardSet.items[i].id)
			SystemNotice(character, deathcircle_conf.notice_heading.."Вы выиграли: "..rewardSet.items[i].quantity.." "..itemName)
		else
			SystemNotice(character, deathcircle_conf.notice_heading.."Ваша сумка полна. Я оставлю все награды себе...")
		end
	end
end


